local fRows, fCols, kRows, kCols, channels, output

terra min(a : int, b : int)
  return terralib.select(a < b, a, b)
end

function blockedloop(N,blocksizes,bodyfn)
  local function generatelevel(n,ii,jj,bb)
    if n > #blocksizes then
      return bodyfn(ii,jj)
    end
    local blocksize = blocksizes[n]
    return quote
      -- receive n, size of block, body fn
      -- it will use the same blocksize for x and y
      -- TEST FOR THE BEST ONE
      for i = ii,min(ii+bb,N),blocksize do
        for j = jj,min(jj+bb,N),blocksize do
          [ generatelevel(n+1,i,j,blocksize) ]
        end
      end
    end
  end
  return generatelevel(1,0,0,N)
end

function slide(inputData, kernel, bb0, bb1, bb2, bb3)
  output = {{0,0,0},{0,0,0},{0,0,0}}
  local t1, t2, t3, t4 = 0, 0, 0, 0 -- index
  local kCenterX, kCenterY = math.floor(kRows/2), math.floor(kCols/2)
  --GENERATED BY BLOCKING
  for t1=0, fRows-1, t1+bb0 do
    for i=t1, math.min(fRows, t1+bb0)-1 do
      for t2=0, fCols-1, t2+bb1 do
        for j=t2, math.min(fCols, t2+bb1)-1 do
          for t3=0, kRows-1, t3+bb2 do
            for m=t3, math.min(kRows, t3+bb2)-1 do
              for t4=0, kCols-1, t4+bb3 do
                for n=t4, math.min(kCols, t4+bb3)-1 do
                  
                  --TERRA CODE
                  local ii, jj = i + (m - kCenterY), j + (n - kCenterX)
                  if ii >= 0 and ii<fRows and jj>=0 and jj<fCols then
                    output[i+1][j+1] = output[i+1][j+1] + inputData[ii+1][jj+1] * kernel[m+1][n+1];
                  end

                end
              end
            end
          end
        end
      end
    end
  end
end

function naiveConvolve(inputData, kernel)
  local kCenterX, kCenterY = math.floor(kRows/2), math.floor(kCols/2)
  output = {{0,0,0},{0,0,0},{0,0,0}}
  for i=0, fRows-1 do
    for j=0, fCols-1 do
      for m=0,kRows-1 do
        --already flipped kernel
        --local mm = kRows - 1 - m
        for n=0,kCols-1 do
          --local nn = kCols - 1 - n
          --boundaries
          local ii = i + (m - kCenterY)
          local jj = j + (n - kCenterX)
          if ii >= 0 and ii< fRows and jj>=0 and jj<fCols then
            local tmp = output[i+1][j+1]
            output[i+1][j+1] = tmp + inputData[ii+1][jj+1] * kernel[i+1][j+1] --kernel[mm+1][nn+1];
          end
        end
      end
    end
  end
end

function check()
  local test, tRows, tCols = {  {-13,-20,-17},
                                {-18,-24,-18},
                                {13,  20, 17}}, 3, 3
  for i=0,tRows-1 do
    for j=0,tCols-1 do
      --return (quote 
        --IO.printf("%d \n", original.get(i,j)) 
        --end)
      --IO.printf("%d", c.test[i][j])
      if output[i+1][j+1] ~= test[i+1][j+1] then
         print "error"
         return false
      end
    end
  end
  return true
end


local function blocking()
  --get image, decompose on RGB, do the convolution operation
  local kernel = getKernel()
  local image = getImage()

  --it should be a method of image that receives a kernel flipped: flip() is a kernel method to flip
  kernel = flipkernel(kernel,kRows,kCols)

  local blockM = {1,2,3}
  local blockN = {1,2,3}
  local blockMM = {1,2,3}
  local blockNN = {2,1,3}
  --local harness = require("lib/matrixtestharness")
  local before = terralib.currenttimeinseconds()
  
  local time
  
  io.write("Parameters: \n")
  for _,rm in ipairs(blockM) do
    for _,rn in ipairs(blockN) do
      for _,rmm in ipairs(blockMM) do
        for _,rnn in ipairs(blockNN) do
          for i=1,channels do
            --tree of times, take the best one 
            slide(image, kernel,rm,rn,rmm,rnn)
            if(check()) then
              time = terralib.currenttimeinseconds() - before
              before = terralib.currenttimeinseconds()
              --io.write("rm: " .. rm .. " rn: " .. rn .. " rmm: " .. rmm .. " rnn: " .. rnn .. "| Time: " .. time .. "\n") 
              io.write(time .. "\n") 
            end
          end
        end
      end
    end
  end
  io.write("Naive: ")
  naiveConvolve(image,kernel)
  time = terralib.currenttimeinseconds() - before
  io.write(time)
end

function equal(a,b,M,N)
  for i=0,M-1 do
    for j=0,N-1 do
      if(a[i+1][j+1] ~= b[i+1][j+1]) then
          io.write(a[i+1][j+1] .. " != " .. b[i+1][j+1] .. "\n")
          return false
      end
    end
  end
  return true
end

function printMatrix(matrix,M,N)
  for i=0,M-1 do
    for j=0,N-1 do
      io.write(" " .. matrix[i+1][j+1])
    end
    io.write("\n")
  end
  io.write("\n")
end

--flip in terra
function flipkernel(kernel,M,N)
  local newKernel = {}
  for m=0,M-1 do
    newKernel[m+1] = {}
    local mm = M - 1 - m
    for n=0,N-1 do 
      local nn = N - 1 - n
      newKernel[m+1][n+1] = kernel[mm+1][nn+1]
    end
  end
  return newKernel
end

IO = terralib.includec("stdio.h")

original = terralib.includecstring [[
  int get(int i, int j){
    int test[3][3] = {{-13,-20,-17}, {-18,-24,-18}, {13,  20, 17}};
    return test[i][j];
  }
]]

function getImage()
  fRows, fCols, channels = 3, 3, 1
  return {{1,2,3},
          {4,5,6},
          {7,8,9}}
end

function getKernel()
  kRows, kCols = 3,3
  return {{-1,-2,-1},
          {0,  0, 0},
          {1,  2, 1}}
end

function ioread()
  io.read ("*n", "*n")
  if (kRows <= 0) or bit.ban(kRows,1) ~= 1 or
    ((kCols <= 0) or ((bit.band(kCols,1)) ~= 1)) then
    print("We assume odd size filter "+
    "in order to have a center element and do the flip")
  end
end

-- multistage programming
IO = terralib.includec("stdio.h")

function sayhello()
  return (quote 
    var x:int 
    x = 2
    IO.printf("%d\n",x)
  end)
end

terra printl()
  --[sayhello()]
  --[check()]
end

--printl()
blocking()